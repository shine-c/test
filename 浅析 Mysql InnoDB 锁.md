## 浅析 Mysql InnoDB 锁

### innoDB  锁的种类:

	自增锁（Auto-inc Locks）
	
	共享/排它锁(Shared and Exclusive Locks)
	
	意向锁(Intention Locks)
	
	插入意向锁(Insert Intention Locks)
	
	记录锁(Record Locks)
	
	间隙锁(Gap Locks)
	
	临键锁(Next-Key Locks)
	
	

### 1: 自增锁（Auto-inc Locks）

	自增锁是一种特殊的表级别锁（table-level lock），专门针对事务插入 AUTO_INCREMENT 类型的列。
	最简单的情况，如果一个事务正在往表中插入记录，所有其他事务的插入必须等待，以便第一个事务插入的行，是连续的主键值。
	
自增锁是可以通过 innodb_autoinc_lock_mode 配置的, innodb_autoinc_lock_mode可以设定3个值，分别为 0，1，2, 目前MySQL默认的配置为1。

	0：traditonal （每次都会产生表锁）

	1：consecutive （会产生一个轻量锁，simple insert会获得批量的锁，保证连续插入）

	2：interleaved （不会锁表，来一个处理一个，并发最高）
 

### 2: 共享/排它锁(Shared and Exclusive Locks)

共享/排它锁, 是InnoDB里实现的标准的行级锁(row-level locking)

	(1)事务拿到某一行记录的共享锁，才可以读取这一行；
	(2)事务拿到某一行记录的排它锁，才可以修改或者删除这一行；
	
其兼容互斥表如下：

| # | S | X  |
|-----|:-----:|:-----:|
|S | 兼容 | 互斥 |
|X | 互斥 | 互斥 |

即：

	(1)多个事务可以拿到一把S锁，读读可以并行;
	(2)而只有一个事务可以拿到X锁，写写/读写必须互斥；

	

### 3: 意向锁(Intention Locks)
InnoDB支持多粒度锁(multiple granularity locking)，它允许行级锁与表级锁共存.意向锁的存在就是为了解决行级锁与表级锁共存共存问题.

意向锁有这样一些特点：

(1)首先，意向锁，是一个表级别的锁(table-level locking)；

(2)意向锁分为：

意向共享锁(intention shared lock, IS)，它预示着，事务有意向对表中的某些行加共享S锁

意向排它锁(intention exclusive lock, IX)，它预示着，事务有意向对表中的某些行加排它X锁



eg：

	事务A锁住了表中的一行，让这一行只能读，不能写。
	
	之后，事务B申请整个表的写锁。
	
	如果事务B申请成功，那么理论上它就能修改表中的任意一行，这与A持有的行锁是冲突的。
	
	数据库需要避免这种冲突，就是说要让B的申请被阻塞，直到A释放了行锁。
	
	数据库要怎么判断这个冲突呢？
	
	step1：判断表是否已被其他事务用表锁锁表
	step2：判断表中的每一行是否已被行锁锁住。
	
	注意step2，这样的判断方法效率实在不高，因为需要遍历整个表。
	于是就有了意向锁。

由于意向锁仅仅表明意向，它其实是比较弱的锁，意向锁之间并不相互互斥，而是可以并行，其兼容互斥表如下：

| # | IS | IX  |
|-----|:-----:|:-----:|
|IS | 兼容 | 兼容 |
|IX | 兼容 | 兼容 |
	


### 4: 插入意向锁(Insert Intention Locks)

对已有数据行的修改与删除，必须加强互斥锁X锁，那对于数据的插入，是否还需要加这么强的锁，来实施互斥呢？插入意向锁，孕育而生。

插入意向锁，是间隙锁(Gap Locks)的一种（所以，也是实施在索引上的），它是专门针对insert操作的。

它的作用是：

多个事务，在同一个索引，同一个范围区间插入记录时，如果插入的位置不冲突，不会阻塞彼此。

### 5: 记录锁(Record Locks)

记录锁，它封锁索引记录，例如：
select * from t where id=1 for update;

它会在id=1的索引记录上加锁，以阻止其他事务插入，更新，删除id=1的这一行。

需要说明的是：

select * from t where id=1;

则是快照读(SnapShot Read)，它并不加锁，具体在《InnoDB为什么并发高，读取快？》中做了详细阐述。


### 6: 间隙锁(Gap Locks)
间隙锁，它封锁索引记录中的间隔，或者第一条索引记录之前的范围，又或者最后一条索引记录之后的范围。

eg: 在 InnoDB，RR：

	t(id PK, name KEY, sex, flag);
	
	表中有四条记录：
	
	1,a, m, A
	
	3,b, m, A
	
	5,c, m, A
	
	9,d, f, B
	
	这个SQL语句
	
	select * from t  where id between 8 and 15 for update;

会封锁区间，以阻止其他事务id=10的记录插入。

间隙锁的主要目的，就是为了防止其他事务在间隔中插入数据，以导致“不可重复读”。

如果把事务的隔离级别降级为读提交(Read Committed, RC)，间隙锁则会自动失效。


### 7: 	临键锁(Next-Key Locks)

临键锁，是记录锁与间隙锁的组合，它的封锁范围，既包含索引记录，又包含索引区间。

更具体的，临键锁会封锁索引记录本身，以及索引记录之前的区间。

临键锁的主要目的，也是为了避免幻读(Phantom Read)。如果把事务的隔离级别降级为RC，临键锁则也会失效。

## 总结

(1)InnoDB使用共享锁，可以提高读读并发；

(2)为了保证数据强一致，InnoDB使用强互斥锁，保证同一行记录修改与删除的串行性；

(3)InnoDB使用插入意向锁，可以提高插入并发；

(4)InnoDB的索引与行记录存储在一起，这一点和MyISAM不一样；

(5)记录锁 锁定索引记录；

(6)间隙锁锁定间隔，防止间隔中被其他事务插入；

(7)临键锁锁定索引记录+间隔，防止幻读；






