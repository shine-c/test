#浅析 ssh

## 1: 什么是ssh 

>传统的网络服务程序，比如FTP，POP，Telnet，本质上都是不安全的，因为它们在网络上用明文传送数据、用户账号和用户口令，很容易受到中间人攻击方式的攻击，攻击者会冒充真正的服务器接收用户传给服务器的数据，然后再冒充用户把数据传给真正的服务器。
    
 >为了满足安全性的需求，Secure Shell（缩写为SSH）就应运而生了，这是一项创建在应用层和传输层基础上的安全协议，为计算机上的Shell提供安全的传输和使用环境。   
    
      
>SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用SSH协议可以有效防止远程管理过程中的信息泄漏问题。通过SSH可以对所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。



## 2: 基本用法

    首先了解~.ssh 下得文件
    know_host : 存储 已经确保正常、可以安全连接的所有服务器(hosts)的公钥。
	authorized_hosts ： 存储 已经认证的客户端的公钥。
	id_rsa.pub ：公钥
	id_rsa ：私钥
	 
	1: 创建一个SSH Key 
	$ ssh-keygen -t rsa -C "你的email地址"
	#代码参数含义： 
	#-t指定密钥类型，默认是rsa，可以省略。 
	#-C设置注释文字，比如邮箱。 
	#-f指定密钥文件存储文件名。
	#生成 id_rsa, id_rsa.pub
	
	2:简单登录 默认端口22
	$ ssh user@host
	
	3: -p  修改默认登录端口
	$ ssh -p 9999 user@host
	
	4: 配置主机别名 配置路径
	Host test # 主机别名，使用`ssh gateway`命令可以直接登录该主机
       Protocol 2  # ssh协议版本
       HostName example.com # 主机地址，支持IP或域名
    	Port 22  # ssh服务端口号
   	 	User root # 登录用户名
   	 	ProxyCommand ssh tbj -W %h:%p # 登录跳板机的ssh指令，这里使用上一条配置的别名
   	 	IdentityFile ~/.ssh/id_rsa # 使用的私钥文件
   	 	
   5: 将公钥传到主机上面
   $ ssh-copy-id user@host
	
--	
## 3: 两种登录方式

1:口令登录（密码的认证）
通常在第一次登录的时候，系统会出现下面提示信息

	$ ssh user@host
	The authenticity of host '127.0.0.1 (127.0.0.1)' can't be established.
	ECDSA key fingerprint is ff:de:a2:d9:55:83:cb:22:f2:b6:0a:28:e1:68:01:68.
	Are you sure you want to continue connecting (yes/no)?

上面的信息说的是：无法确认主机host(12.18.429.21)的真实性，不过知道它的公钥指纹，询问你是否继续连接？

所谓"公钥指纹"，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是de:a2:d9:55:83:cb:22:f2:b6:0a:28:e1:68:01:68，再进行比较，就容易多了

	之所以用fingerprint代替key，主要是key过于长（RSA算法生成的公钥有1024位），很难直接比
	较。所以，对公钥进行hash生成一个128位的指纹，这样就方便比较了
	
很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？

回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对，或者自己甄别host地址是否正确。

当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。
每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。

2、公钥登录（基于公钥的认证）
使用密码登录，每次都必须输入密码，非常麻烦。好在SSH提供了另外一种可以免去输入密码过程的登录方式：公钥登录
	
	




## 4:ssh如何实现数据安全

为了保证信息传输的安全性，SSH使用了下以技术：
> 对称加密（也称为对称加密、私钥加密、共享密钥加密）

> 非对称加密（也称公钥加密）
 
> 散列

***
#####对称加密

所谓对称加密，就是加密解密使用同一套秘钥。如下图所示：
对称加密-Client端
![](https://images2015.cnblogs.com/blog/538639/201706/538639-20170601180312493-487631940.png)
对称加密-Server端
![](https://images2015.cnblogs.com/blog/538639/201706/538639-20170601180333571-85555273.png)

SSH支持多种对称密钥算法，包括AES，Blowfish，3DES，CAST128和Arcfour。客户端和服务端可以配置
采用算法的列表。客户端列表中第一个能被服务端支持的算法将被采用

特性:

	优点：速度快，对称性加密通常在消息发送方需要加密大量数据时使用，算法公开、计算量小、加密速度
	快、加密效率高。
	
	缺点：在数据传送前，发送方和接收方必须商定好秘钥，然后 使双方都能保存好秘钥。其次如果一方的
	秘钥被泄露，那么加密信息也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人
	不知道的唯一秘 钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。
在ssh中的使用:

	SSH使用对称加密在整个连接过程中传输的信息。值得注意的是，用户自己创建的public/private密
	钥对仅仅用于验证，不会用在加密连接上。对称加密允许对密码进行身份验证，以防止第三方窥探。
	
	对称加密的共享密钥通过密钥交换算法生成，它可以让双方在完全没有对方任何预先信息的条件下通过不
	安全信道创建起一个密钥。
	
	客户端和服务端都参与了这个过程，过程的细节将在后面阐述。

***
####非对称加密
在非对称加密方法中，需要一对密钥，一个是私钥，一个是公钥。这两个密钥数学相关。用公钥加密后所得的信息，只能用私钥才能解密。如果知道了其中一个，并不能计算另外一个。因此，如果公开了一对密钥中的一个，并不会危害到另外一个的秘密性质。

![](https://images2015.cnblogs.com/blog/538639/201706/538639-20170601184656461-1152781300.png)

特性:

	优点：安全,公钥加密后的密文，只能通过其对应的私钥进行解密。
	通过公钥推理出私钥的可能性微乎其微。
	
	缺点：速度较慢
	
在ssh中的使用:

	在密钥交换过程中使用到了非对称加密。在这个阶段，客户端和服务端生成临时密钥对，并且交换公钥来
	生成共享密钥。
	
	在身份验证的过程中也使用了非对称加密。SSH密钥对用来向服务端验证客户端身份。客户端创建一对密
	钥，然后将公钥上传到远程服务器上，写入文件~/.ssh/authorized_keys。
	
	在创建共享密钥后，客户端必须向服务端证明身份。服务端会使用文件中的公钥加密一段信息，并将加密
	后的信息发送给客户端。如果客户端可以能够破解这段信息，那么就能够证明自己拥有相关的私钥。之后
	服务端会为客户端设置shell环境。

***
####散列

散列是电脑科学中一种对资料的处理方法，它通过某种特定的算法将要检索的项与涌来检索的索引关联起来，生成一种便于搜索的数据结构（散列表）。它也常用做一种资讯安全的方法，由一串资料中经过散列算法计算出来的资料指纹，来识别档案和资料是否有被篡改

在ssh中的使用:

	SSH主要使用了散列消息认证码（Keyed-hash message authentication code，缩写为HMAC)，
	来确认消息没有被篡改。
	
	上面提到的对称加密协商过程中，会使用消息认证码（MAC）算法。这个算法会从客户端支持的算法中选
	出。

	在密钥协商完成后，所有的消息都必须携带MAC，用于通信双方验证消息的一致性。MAC值由共享密钥
	，消息的分组序列和实际消息内容计算得到。
	
## 5:SSH工作流程
	1:SSH协议采用客户端-服务端模型对两方进行身份验证，并对它们之间的数据进行加密。
	
	2: 服务端 sshd 进程会在指定端口监听连接请求.它负责协商安全连接，认证连接方，并为客户端生成正确的shell环境。
	
	3: 客户端负责协商安全连接，验证服务器的身份是否与以前记录的信息相匹配，并提供凭证进行身份验证。

	4:SSH会话分为两个阶段:
	    * 会话加密协商 (同意和建立加密来保护未来的沟通).
	    * 验证用户身份，并发现是否应该授予对服务器的访问权限。

	    
####会话加密协商:

当客户端发起请求后，服务端返回支持的协议版本。如果客户端可以匹配其中一个协议版本，则连接继续。服务端会提供它的公共主机密钥，客户端可以用这个密钥来验证服务端是否合法。

此时，通信双方采用迪菲-赫尔曼算法来协商会话密钥。迪菲－赫尔曼密钥交换（Diffie–Hellman key exchange，简称“D–H”）是一种安全协议。它可以让双方在完全没有对方任何预先信息的条件下通过不安全信道创建起一个密钥。这个密钥可以在后续的通讯中作为对称密钥来加密通讯内容。
在了解算法的过程钱我们先了解下大质数加密

>tips  大质数加密的原理: 

只能被1和本身整除的数叫质数,例如13,质数是无穷多的.得到两个巨大质数的乘积是简单的事,但想从该乘积反推出这两个巨大质数却没有任何有效的办法,这种不可逆的单向数学关系,是国际数学界公认的质因数分
解难题.
  R、S、A三人巧妙利用这一假说,设计出RSA公匙加密算法的基本原理：
 
 	1、让计算机随机生成两个大质数p和q,得出乘积n；
 	2、利用p和q有条件的生成加密密钥e；
 	3、通过一系列计算,得到与n互为质数的解密密钥d,置于操作系统才知道的地方；
 	4、操作系统将n和e共同作为公匙对外发布,将私匙d秘密保存,把初始质数p和q秘密丢弃.
 	
国际数学和密码学界已证明,企图利用公匙和密文推断出明文--或者企图利用公匙推断出私匙的难度等同于分解两个巨大质数的积.这就是Eve不可能对Alice的密文解密以及公匙可以在网上公布的原因.

至于"巨大质数"要多大才能保证安全的问题不用担心：利用当前可预测的计算能力,在十进制下,分解两个250位质数的积要用数十万年的时间；并且质数用尽或两台计算机偶然使用相同质数的概率小到可以被忽略.

//3:双方各自生成一个素数，得出乘积n。通过一系列计算私钥
该算法的大致过程如下：

![](https://zh.wikipedia.org/wiki/File:Diffie-Hellman-Schl%C3%BCsselaustausch.svg)

	以下是一个更为一般的描述:

	1:爱丽丝和鲍伯写上一个有限循环群 G 和它的一个生成元生成元 g。 （这通常在协议开始很久以前就已经规定好； g是公开的，并可以被所有的攻击者看到。）
	2:爱丽丝选择一个随机自然数 a 并且将g^{a} \bmod{p}发送给鲍伯。
	4:鲍伯选择一个随机自然数 b 并且将g^{b} \bmod{p}发送给爱丽丝。
	5:爱丽丝 计算\left ( g^{b} \right )^{a} \bmod{p}。
	6:鲍伯 计算\left ( g^{a} \right )^{b} \bmod{p}。

	1:双方协定共享一个大素数。
	2:双方协定一个加密算法。
	3:双方各自生成一个素数，并保密。这个素数将作为私钥。
	4:双方使用协定的算法，由各自的私钥和共享的素数计算得到公钥。
	5:双方交换生成的公钥。
	6:双方使用各自的私钥，另外一方的公钥和共享的素数，计算得到一个共享密钥。双方计算得到的共享密
	钥应该是一样的。
	7:使用共享密钥加密后面的会话。
	
生成的密钥是对称密钥，这意味着用于加密消息的密钥也可以用于解密。其目的是将后面的通信包装在不能被外部人员解密的加密隧道中。

在生成会话密钥后，就开始进行用户身份验证。

####验证用户身份

根据服务器接受的方式，有几种不同的方法可用于身份验证。

最简单的方法是密码验证，其中服务器要求客户端输入尝试登陆账号的密码。密码是通过协商加密发送的。

虽然密码被加密，但由于密码的复杂性受到限制，因此通常不建议使用此方法。与其他身份验证的方法相比，自动脚本相对容易攻破正常长度的密码。

最为推荐的选择是使用SSH密钥对。SSH密钥对是非对称密钥。

公钥用于加密只能用私钥解密的数据。公钥可以自由共享，因为没有从公钥中导出私钥的方法。


验证流程如下：

	1:客户端首先向服务端发送密钥对的ID。
	2:服务端检查文件authorized_keys寻找该ID的公钥。
	3:如果找到，服务端生成一个随机数，并使用公钥加密这个数。
	4:服务端将加密后的信息发送给客户端。
	5:如果客户端拥有对应的私钥，那么就能使用私钥解密消息，得到服务端生成的随机数。
	6:客户端使用解密后的数和会话使用的共享密钥得到一个值，然后计算这个值的MD5散列值。
	7:客户端将这个MD5散列值发送回服务端。
	8:服务端用会话共享密钥和生成的随机值计算得到自己的MD5散列值。然后比较客户端传回的值和自身生
	成的值。如果匹配，则证明客户端拥有私钥，客户端验证通过。



	    





